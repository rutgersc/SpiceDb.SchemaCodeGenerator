using SpiceDb.SchemaCodeGenerator.Schema;

namespace SpiceDb.SchemaCodeGenerator;

public static class SchemaCodeGenerator
{
    public static string GenerateFullSchema(Schema.Schema schema)
    {
        var definitionIds = schema.Definitions.ToDictionary(
            definition => definition.FullName,
            definition => definition.IdType);

        var wildcardRelations = schema.Definitions
            .SelectMany(definition =>
                definition.Relations.SelectMany(relation =>
                    relation.Types.SelectWhereNotNull(relationType =>
                        relationType.IsWildcard
                            ? relationType.FullName
                            : null)))
            .ToHashSet();

        return $$"""
// <auto-generated/>
#nullable enable
using System;
using Authzed.Api.V1;
using Google.Protobuf.Collections;
using Google.Protobuf.WellKnownTypes;

public static class AuthorizationSchema
{
{{schema.Definitions.Select(d => GenerateClassFromDefinition(wildcardRelations, definitionIds, d) ).JoinStrings("\n")}}

    public static class Caveat
    {
{{schema.Caveats.Select(GenerateClassFromCaveat).JoinStrings("\n")}}
    }
}
""";
    }

static string GenerateClassFromDefinition(HashSet<string> wildcardRelations, Dictionary<string,string> definitionIds, Definition definition)
{
    var hasWildcard = wildcardRelations.Contains(definition.FullName);

    var definitionClass = $$$""""
    public static partial class {{{definition.Name}}}
    {
        public static ObjectReference ObjectRef({{{definition.IdType}}} id) =>
            new ObjectReference { ObjectType = "{{{definition.FullName}}}", ObjectId = id.ToString({{{definition.IdTypeToStringArgument}}}) };

        public static SubjectReference SubjectRef({{{definition.IdType}}} id, string? optionalRelation = null) =>
            new SubjectReference { Object = ObjectRef(id), OptionalRelation = optionalRelation };

{{{(hasWildcard
    ? $$"""
        public static SubjectReference SubjectRefWildcard() =>
            new SubjectReference { Object = new ObjectReference { ObjectType = "{{definition.FullName}}", ObjectId = "*" } };
"""
    : "")}}}

        public static class Relation
        {
            public enum Enum
            {
{{{definition.Relations.Select(relation =>
                {
                    return $"""
                {relation.Name},
""";
                }).JoinStrings($"\n")
}}}
            }

{{{definition.Relations.Select(relation =>
            {
                return $$"""
{{relation.Types.Select(relationType =>
                    {
                        var subjectType = $"AuthorizationSchema.{relationType.Type}";
                        var subjectTypeIdType = definitionIds[relationType.FullName];

                        var relationOptionalRelation = relationType.NoRelation
                            ? "".SurroundWith('"')
                            : relationType.Relation.SurroundWith('"');

                        var caveatParam = relationType.Caveat == null
                            ? ""
                            : $", Caveat.{relationType.Caveat} caveat";

                        var caveatUsage = relationType.Caveat == null
                            ? ""
                            : $", OptionalCaveat = caveat.ToContextualizedCaveat()";

                        var relationTypeAsRelation = $$"""
            public static Relationship {{relation.Name}}_{{relationType.Type}}({{definition.IdType}} id, {{subjectTypeIdType}} subjectId{{caveatParam}}) =>
                new Relationship { Resource = ObjectRef(id), Relation = "{{relation.Name}}", Subject = {{subjectType}}.SubjectRef(subjectId, {{relationOptionalRelation}}){{caveatUsage}} };
""";
                        var relationTypeAsWildcard = $$"""
            public static Relationship {{relation.Name}}_{{relationType.Type}}_Wildcard({{definition.IdType}} id{{caveatParam}}) =>
                new Relationship { Resource = ObjectRef(id), Relation = "{{relation.Name}}", Subject = {{subjectType}}.SubjectRefWildcard(){{caveatUsage}} };
""";

                        return relationType.IsWildcard
                            ? relationTypeAsWildcard
                            : relationTypeAsRelation;
                    }).JoinStrings("\n\n")
}}
""";
            }).JoinStrings("\n\n")
}}}
        }

        public static class Permission
        {
{{{definition.Permissions.Select(permission =>
                {
                    var subjectTypeName = "user";
                    var subjectType = $"AuthorizationSchema.{subjectTypeName}";
                    var subjectTypeIdType = definitionIds[subjectTypeName];

                    return $$"""
            public static CheckPermissionRequest {{permission.Name}}({{definition.IdType}} objectId, SubjectReference subject) =>
                new() { Resource = {{definition.Name}}.ObjectRef(objectId), Permission = "{{permission.Name}}", Subject = subject };

            public static CheckPermissionRequest {{permission.Name}}({{definition.IdType}} objectId, {{subjectTypeIdType}} subjectId) =>
                new() { Resource = {{definition.Name}}.ObjectRef(objectId), Permission = "{{permission.Name}}", Subject = {{subjectType}}.SubjectRef(subjectId) };

""";
                }).JoinStrings("\n")
            }}}
        }
    }
"""";

        return definitionClass;
    }

    static (string CsharpType, string ToCelType) GetCaveatTypeConversion(string caveatType, string csharpClassPropertyAccessor)
    {
        // https://github.com/authzed/spicedb/tree/main/pkg/caveats/types
        // Spicedb 'ContextualizedCaveat' uses 'Struct': fields which map to dynamically typed values. https://github.com/google/cel-spec/blob/master/doc/langdef.md#dynamic-values
        return caveatType switch
        {
            "int" => ("int", $"Value.ForNumber({csharpClassPropertyAccessor})"),
            "uint" => ("uint", $"Value.ForNumber({csharpClassPropertyAccessor})"),
            "bool" => ("bool", $"Value.ForBool({csharpClassPropertyAccessor})"),
            "double" => ("double", $"Value.ForNumber({csharpClassPropertyAccessor})"),
            "bytes" => ("byte[]", $"Value.ForString({csharpClassPropertyAccessor}.ToString())"),
            "duration" => ("Duration", $"Value.ForString({csharpClassPropertyAccessor}.ToString())"),
            "timestamp" => ("Timestamp", $"Value.ForString({csharpClassPropertyAccessor}.ToString()"),
            not null when caveatType.Contains('<') => ("string", $"Value.ForString({csharpClassPropertyAccessor})"),
            "ipaddress" => ("IpAddress", $"Value.ForString({csharpClassPropertyAccessor}.ToString())"),
            _ => ("string", $"Value.ForString({csharpClassPropertyAccessor})")
        };
    }

    static string GenerateClassFromCaveat(Caveat caveat)
    {
        return $$"""
        public class {{caveat.Name}}
        {
{{caveat.Parameters.Select(caveatParameter =>
    {
        var propertyAccessor = $"this.{caveatParameter.Key}";
        var (csharpType, _) = GetCaveatTypeConversion(caveatParameter.Value, propertyAccessor);

        return $$"""
            public {{csharpType}} {{caveatParameter.Key}} { get; set; }
""";
    }).JoinStrings("\n")
}}

            public ContextualizedCaveat ToContextualizedCaveat()
            {
                var protoStruct = new Struct();
{{caveat.Parameters.Select(caveatParameter =>
    {
        var propertyAccessor = $"this.{caveatParameter.Key}";
        var (_, toCelType) = GetCaveatTypeConversion(caveatParameter.Value, propertyAccessor);

        return $$"""
                if ({{propertyAccessor}} != null)
                {
                    protoStruct.Fields.Add("{{caveatParameter.Key}}", {{toCelType}}));
                }
""";
    }).JoinStrings("\n")
}}

                return new ContextualizedCaveat()
                {
                    CaveatName = "{{caveat.Name}}",
                    Context = protoStruct
                };
            }
        }
""";
    }
}